{"ast":null,"code":"/**\n * Script loading is difficult thanks to IE. We need callbacks to fire\n * immediately following the script's execution, with no other scripts\n * running in between. If other scripts on the page are able to run\n * between our script and its callback, bad things can happen, such as\n * `jQuery.noConflict` not being called in time, resulting in plugins\n * latching onto our version of jQuery, etc.\n *\n * For IE<10 we use a relatively well-documented \"preloading\" strategy,\n * which ensures that the script is ready to execute *before* appending\n * it to the DOM. That way when it is finally appended, it is\n * executed immediately.\n *\n * References:\n * - http://www.html5rocks.com/en/tutorials/speed/script-loading/\n * - http://blog.getify.com/ie11-please-bring-real-script-preloading-back/\n * - https://github.com/jrburke/requirejs/issues/526\n * - https://connect.microsoft.com/IE/feedback/details/729164/\n *           ie10-dynamic-script-element-fires-loaded-readystate-prematurely\n */\n(function () {\n  // Global state.\n  var pendingScripts = {};\n  var scriptCounter = 0;\n  /**\n   * Insert script into the DOM\n   *\n   * @param {Object} script Script DOM object\n   * @returns {void}\n   */\n\n  var _addScript = function (script) {\n    // Get the first script element, we're just going to use it\n    // as a reference for where to insert ours. Do NOT try to do\n    // this just once at the top and then re-use the same script\n    // as a reference later. Some weird loaders *remove* script\n    // elements after the browser has executed their contents,\n    // so the same reference might not have a parentNode later.\n    var firstScript = document.getElementsByTagName(\"script\")[0]; // Append the script to the DOM, triggering execution.\n\n    firstScript.parentNode.insertBefore(script, firstScript);\n  };\n  /**\n   * Load Script.\n   *\n   * @param {String}            src       URI of script\n   * @param {Function|Object}   callback  (Optional) Called on script load completion,\n   *                                      or options object\n   * @param {Object}            context   (Optional) Callback context (`this`)\n   * @returns {void}\n   */\n\n\n  var _lload = function (src, callback, context) {\n    /*eslint max-statements: [2, 32]*/\n    var setup;\n\n    if (callback && typeof callback !== \"function\") {\n      context = callback.context || context;\n      setup = callback.setup;\n      callback = callback.callback;\n    }\n\n    var script = document.createElement(\"script\");\n    var done = false;\n    var err;\n\n    var _cleanup; // _must_ be set below.\n\n    /**\n     * Final handler for error or completion.\n     *\n     * **Note**: Will only be called _once_.\n     *\n     * @returns {void}\n     */\n\n\n    var _finish = function () {\n      // Only call once.\n      if (done) {\n        return;\n      }\n\n      done = true; // Internal cleanup.\n\n      _cleanup(); // Callback.\n\n\n      if (callback) {\n        callback.call(context, err);\n      }\n    };\n    /**\n     * Error handler\n     *\n     * @returns {void}\n     */\n\n\n    var _error = function () {\n      err = new Error(src || \"EMPTY\");\n\n      _finish();\n    };\n\n    if (script.readyState && !(\"async\" in script)) {\n      /*eslint-disable consistent-return*/\n      // This section is only for IE<10. Some other old browsers may\n      // satisfy the above condition and enter this branch, but we don't\n      // support those browsers anyway.\n      var id = scriptCounter++;\n      var isReady = {\n        loaded: true,\n        complete: true\n      };\n      var inserted = false; // Clear out listeners, state.\n\n      _cleanup = function () {\n        script.onreadystatechange = script.onerror = null;\n        pendingScripts[id] = void 0;\n      }; // Attach the handler before setting src, otherwise we might\n      // miss events (consider that IE could fire them synchronously\n      // upon setting src, for example).\n\n\n      script.onreadystatechange = function () {\n        var firstState = script.readyState; // Protect against any errors from state change randomness.\n\n        if (err) {\n          return;\n        }\n\n        if (!inserted && isReady[firstState]) {\n          inserted = true; // Append to DOM.\n\n          _addScript(script);\n        } // --------------------------------------------------------------------\n        //                       GLORIOUS IE8 HACKAGE!!!\n        // --------------------------------------------------------------------\n        //\n        // Oh IE8, how you disappoint. IE8 won't call `script.onerror`, so\n        // we have to resort to drastic measures.\n        // See, e.g. http://www.quirksmode.org/dom/events/error.html#t02\n        //\n        // As with all things development, there's a Stack Overflow comment that\n        // asserts the following combinations of state changes in IE8 indicate a\n        // script load error. And crazily, it seems to work!\n        //\n        // http://stackoverflow.com/a/18840568/741892\n        //\n        // The `script.readyState` transitions we're interested are:\n        //\n        // * If state starts as `loaded`\n        // * Call `script.children`, which _should_ change state to `complete`\n        // * If state is now `loading`, then **we have a load error**\n        //\n        // For the reader's amusement, here is HeadJS's catalog of various\n        // `readyState` transitions in normal operation for IE:\n        // https://github.com/headjs/headjs/blob/master/src/2.0.0/load.js#L379-L419\n\n\n        if (firstState === \"loaded\") {\n          // The act of accessing the property should change the script's\n          // `readyState`.\n          //\n          // And, oh yeah, this hack is so hacky-ish we need the following\n          // eslint disable...\n\n          /*eslint-disable no-unused-expressions*/\n          script.children;\n          /*eslint-enable no-unused-expressions*/\n\n          if (script.readyState === \"loading\") {\n            // State transitions indicate we've hit the load error.\n            //\n            // **Note**: We are not intending to _return_ a value, just have\n            // a shorter short-circuit code path here.\n            return _error();\n          }\n        } // It's possible for readyState to be \"complete\" immediately\n        // after we insert (and execute) the script in the branch\n        // above. So check readyState again here and react without\n        // waiting for another onreadystatechange.\n\n\n        if (script.readyState === \"complete\") {\n          _finish();\n        }\n      }; // Onerror handler _may_ work here.\n\n\n      script.onerror = _error; // Since we're not appending the script to the DOM yet, the\n      // reference to our script element might get garbage collected\n      // when this function ends, without onreadystatechange ever being\n      // fired. This has been witnessed to happen. Adding it to\n      // `pendingScripts` ensures this can't happen.\n\n      pendingScripts[id] = script; // call the setup callback to mutate the script tag\n\n      if (setup) {\n        setup.call(context, script);\n      } // This triggers a request for the script, but its contents won't\n      // be executed until we append it to the DOM.\n\n\n      script.src = src; // In some cases, the readyState is already \"loaded\" immediately\n      // after setting src. It's a lie! Don't append to the DOM until\n      // the onreadystatechange event says so.\n    } else {\n      // This section is for modern browsers, including IE10+.\n      // Clear out listeners.\n      _cleanup = function () {\n        script.onload = script.onerror = null;\n      };\n\n      script.onerror = _error;\n      script.onload = _finish;\n      script.async = true;\n      script.charset = \"utf-8\"; // call the setup callback to mutate the script tag\n\n      if (setup) {\n        setup.call(context, script);\n      }\n\n      script.src = src; // Append to DOM.\n\n      _addScript(script);\n    }\n  }; // UMD wrapper.\n\n  /*global define:false*/\n\n\n  if (typeof exports === \"object\" && typeof module === \"object\") {\n    // CommonJS\n    module.exports = _lload;\n  } else if (typeof define === \"function\" && define.amd) {\n    // AMD\n    define([], function () {\n      return _lload;\n    });\n  } else {\n    // VanillaJS\n    window._lload = _lload;\n  }\n})();","map":{"version":3,"sources":["/Users/rossmacdonald/Projects/parkfinder/node_modules/little-loader/lib/little-loader.js"],"names":["pendingScripts","scriptCounter","_addScript","script","firstScript","document","getElementsByTagName","parentNode","insertBefore","_lload","src","callback","context","setup","createElement","done","err","_cleanup","_finish","call","_error","Error","readyState","id","isReady","loaded","complete","inserted","onreadystatechange","onerror","firstState","children","onload","async","charset","exports","module","define","amd","window"],"mappings":"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","sourcesContent":["/**\n * Script loading is difficult thanks to IE. We need callbacks to fire\n * immediately following the script's execution, with no other scripts\n * running in between. If other scripts on the page are able to run\n * between our script and its callback, bad things can happen, such as\n * `jQuery.noConflict` not being called in time, resulting in plugins\n * latching onto our version of jQuery, etc.\n *\n * For IE<10 we use a relatively well-documented \"preloading\" strategy,\n * which ensures that the script is ready to execute *before* appending\n * it to the DOM. That way when it is finally appended, it is\n * executed immediately.\n *\n * References:\n * - http://www.html5rocks.com/en/tutorials/speed/script-loading/\n * - http://blog.getify.com/ie11-please-bring-real-script-preloading-back/\n * - https://github.com/jrburke/requirejs/issues/526\n * - https://connect.microsoft.com/IE/feedback/details/729164/\n *           ie10-dynamic-script-element-fires-loaded-readystate-prematurely\n */\n(function () {\n\n  // Global state.\n  var pendingScripts = {};\n  var scriptCounter = 0;\n\n  /**\n   * Insert script into the DOM\n   *\n   * @param {Object} script Script DOM object\n   * @returns {void}\n   */\n  var _addScript = function (script) {\n    // Get the first script element, we're just going to use it\n    // as a reference for where to insert ours. Do NOT try to do\n    // this just once at the top and then re-use the same script\n    // as a reference later. Some weird loaders *remove* script\n    // elements after the browser has executed their contents,\n    // so the same reference might not have a parentNode later.\n    var firstScript = document.getElementsByTagName(\"script\")[0];\n\n    // Append the script to the DOM, triggering execution.\n    firstScript.parentNode.insertBefore(script, firstScript);\n  };\n\n  /**\n   * Load Script.\n   *\n   * @param {String}            src       URI of script\n   * @param {Function|Object}   callback  (Optional) Called on script load completion,\n   *                                      or options object\n   * @param {Object}            context   (Optional) Callback context (`this`)\n   * @returns {void}\n   */\n  var _lload = function (src, callback, context) {\n    /*eslint max-statements: [2, 32]*/\n    var setup;\n\n    if (callback && typeof callback !== \"function\") {\n      context = callback.context || context;\n      setup = callback.setup;\n      callback = callback.callback;\n    }\n\n    var script = document.createElement(\"script\");\n    var done = false;\n    var err;\n    var _cleanup; // _must_ be set below.\n\n    /**\n     * Final handler for error or completion.\n     *\n     * **Note**: Will only be called _once_.\n     *\n     * @returns {void}\n     */\n    var _finish = function () {\n      // Only call once.\n      if (done) { return; }\n      done = true;\n\n      // Internal cleanup.\n      _cleanup();\n\n      // Callback.\n      if (callback) {\n        callback.call(context, err);\n      }\n    };\n\n    /**\n     * Error handler\n     *\n     * @returns {void}\n     */\n    var _error = function () {\n      err = new Error(src || \"EMPTY\");\n      _finish();\n    };\n\n    if (script.readyState && !(\"async\" in script)) {\n      /*eslint-disable consistent-return*/\n\n      // This section is only for IE<10. Some other old browsers may\n      // satisfy the above condition and enter this branch, but we don't\n      // support those browsers anyway.\n\n      var id = scriptCounter++;\n      var isReady = { loaded: true, complete: true };\n      var inserted = false;\n\n      // Clear out listeners, state.\n      _cleanup = function () {\n        script.onreadystatechange = script.onerror = null;\n        pendingScripts[id] = void 0;\n      };\n\n      // Attach the handler before setting src, otherwise we might\n      // miss events (consider that IE could fire them synchronously\n      // upon setting src, for example).\n      script.onreadystatechange = function () {\n        var firstState = script.readyState;\n\n        // Protect against any errors from state change randomness.\n        if (err) { return; }\n\n        if (!inserted && isReady[firstState]) {\n          inserted = true;\n\n          // Append to DOM.\n          _addScript(script);\n        }\n\n        // --------------------------------------------------------------------\n        //                       GLORIOUS IE8 HACKAGE!!!\n        // --------------------------------------------------------------------\n        //\n        // Oh IE8, how you disappoint. IE8 won't call `script.onerror`, so\n        // we have to resort to drastic measures.\n        // See, e.g. http://www.quirksmode.org/dom/events/error.html#t02\n        //\n        // As with all things development, there's a Stack Overflow comment that\n        // asserts the following combinations of state changes in IE8 indicate a\n        // script load error. And crazily, it seems to work!\n        //\n        // http://stackoverflow.com/a/18840568/741892\n        //\n        // The `script.readyState` transitions we're interested are:\n        //\n        // * If state starts as `loaded`\n        // * Call `script.children`, which _should_ change state to `complete`\n        // * If state is now `loading`, then **we have a load error**\n        //\n        // For the reader's amusement, here is HeadJS's catalog of various\n        // `readyState` transitions in normal operation for IE:\n        // https://github.com/headjs/headjs/blob/master/src/2.0.0/load.js#L379-L419\n        if (firstState === \"loaded\") {\n          // The act of accessing the property should change the script's\n          // `readyState`.\n          //\n          // And, oh yeah, this hack is so hacky-ish we need the following\n          // eslint disable...\n          /*eslint-disable no-unused-expressions*/\n          script.children;\n          /*eslint-enable no-unused-expressions*/\n\n          if (script.readyState === \"loading\") {\n            // State transitions indicate we've hit the load error.\n            //\n            // **Note**: We are not intending to _return_ a value, just have\n            // a shorter short-circuit code path here.\n            return _error();\n          }\n        }\n\n        // It's possible for readyState to be \"complete\" immediately\n        // after we insert (and execute) the script in the branch\n        // above. So check readyState again here and react without\n        // waiting for another onreadystatechange.\n        if (script.readyState === \"complete\") {\n          _finish();\n        }\n      };\n\n      // Onerror handler _may_ work here.\n      script.onerror = _error;\n\n      // Since we're not appending the script to the DOM yet, the\n      // reference to our script element might get garbage collected\n      // when this function ends, without onreadystatechange ever being\n      // fired. This has been witnessed to happen. Adding it to\n      // `pendingScripts` ensures this can't happen.\n      pendingScripts[id] = script;\n\n      // call the setup callback to mutate the script tag\n      if (setup) {\n        setup.call(context, script);\n      }\n\n      // This triggers a request for the script, but its contents won't\n      // be executed until we append it to the DOM.\n      script.src = src;\n\n      // In some cases, the readyState is already \"loaded\" immediately\n      // after setting src. It's a lie! Don't append to the DOM until\n      // the onreadystatechange event says so.\n\n    } else {\n      // This section is for modern browsers, including IE10+.\n\n      // Clear out listeners.\n      _cleanup = function () {\n        script.onload = script.onerror = null;\n      };\n\n      script.onerror = _error;\n      script.onload = _finish;\n      script.async = true;\n      script.charset = \"utf-8\";\n\n      // call the setup callback to mutate the script tag\n      if (setup) {\n        setup.call(context, script);\n      }\n\n      script.src = src;\n\n      // Append to DOM.\n      _addScript(script);\n    }\n  };\n\n  // UMD wrapper.\n  /*global define:false*/\n  if (typeof exports === \"object\" && typeof module === \"object\") {\n    // CommonJS\n    module.exports = _lload;\n\n  } else if (typeof define === \"function\" && define.amd) {\n    // AMD\n    define([], function () { return _lload; });\n\n  } else {\n    // VanillaJS\n    window._lload = _lload;\n  }\n}());\n"]},"metadata":{},"sourceType":"script"}